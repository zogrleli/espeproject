#!/usr/bin/env python3
# Online-only: SlideRule ATL03 -> MAD + density + neighbor filters
# Output: kept_out[(granule_id, beam)] = {"x_keep": ..., "z_keep": ...}
# deps: sliderule numpy matplotlib pyproj

from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from pyproj import Transformer

# ------------------ CONFIG (edit these) ------------------
AOI   = (-68.5, 77.30, -67.5, 77.40)          # minlon, minlat, maxlon, maxlat
TIME  = ("2019-09-01T00:00:00Z", "2019-09-30T23:59:59Z")
LMH   = [2, 3, 4]                              # photon confidence to keep server-side
BEAMS = ["gt1l","gt1r","gt2l","gt2r","gt3l","gt3r"]
SLIDERULE_ENDPOINT = "slideruleearth.io"

# Softer defaults (your settings)
WINDOW_M   = 80.0
Q_LOW      = 0.5
Q_HIGH     = 3.0
ITERATE_ONCE = False

DX_BIN       = 20.0
DZ_BIN       = 3.0
MIN_BIN_COUNT= 3

NEI_RX   = 25.0
NEI_DZ   = 3.0
NEI_K    = 2

# Toggle steps on/off to debug
USE_MAD      = True
USE_DENSITY  = True
USE_NEIGHBOR = True

# UTM for along-track distances (same approach as your local code)
to_utm = Transformer.from_crs("EPSG:4326","EPSG:32620", always_xy=True)

# ------------------ UTILITIES ------------------
def _nanmedian_mad(a):
    med = np.nanmedian(a)
    mad = np.nanmedian(np.abs(a - med))
    return med, mad

def robust_line(x, y, max_pairs=20000):
    x = np.asarray(x); y = np.asarray(y)
    n = x.size
    if n < 2:
        return 0.0, (np.nanmedian(y) if n else 0.0)
    rng = np.random.default_rng(0)
    i = rng.integers(0, n, size=min(max_pairs, n))
    j = rng.integers(0, n, size=min(max_pairs, n))
    msk = (j != i); i, j = i[msk], j[msk]
    if i.size == 0:
        A = np.vstack([x, np.ones_like(x)]).T
        m, b = np.linalg.lstsq(A, y, rcond=None)[0]
        return float(m), float(b)
    slopes = (y[j]-y[i])/(x[j]-x[i])
    m = np.nanmedian(slopes)
    b = np.nanmedian(y - m*x)
    return float(m), float(b)

def alongtrack_from_EN(E, N):
    d = np.hypot(np.diff(E), np.diff(N))
    return np.concatenate(([0.0], np.cumsum(d)))

def mad_gate(x,res,W,qL,qH):
    xmin,xmax = x.min(), x.max()
    nb = max(1, int(np.ceil((xmax-xmin)/W)))
    edges = np.linspace(xmin, xmax, nb+1)
    idx = np.clip(np.searchsorted(edges, x, side="right")-1, 0, nb-1)
    keep = np.zeros_like(res, bool)
    for b in range(nb):
        m = (idx==b)
        if m.sum()<10: continue
        r = res[m]
        med, mad = _nanmedian_mad(r)
        if mad==0: mad = np.nanmedian(np.abs(r-med))+1e-6
        lo = med - (qL/0.6745)*mad
        hi = med + (qH/0.6745)*mad
        keep[m] = (r>=lo)&(r<=hi)
    return keep

def density_filter(x,res,dx,dz,minc):
    xe = np.arange(x.min(), x.max()+dx, dx)
    ze = np.arange(np.nanmin(res), np.nanmax(res)+dz, dz)
    xi = np.clip(np.searchsorted(xe,x,side="right")-1, 0, len(xe)-2)
    zi = np.clip(np.searchsorted(ze,res,side="right")-1, 0, len(ze)-2)
    flat = xi*(len(ze)-1)+zi
    u,c = np.unique(flat, return_counts=True)
    good = set(u[c>=minc])
    return np.array([(xi[k]*(len(ze)-1)+zi[k]) in good for k in range(x.size)])

def neighbor_filter(x,res,rx,dz,k):
    order = np.argsort(x)
    xs, rs = x[order], res[order]
    keep_ord = np.zeros_like(xs, bool)
    j0 = 0
    for i in range(xs.size):
        xi = xs[i]
        while xs[j0] < xi-rx and j0 < i:
            j0 += 1
        j1 = i
        while j1+1<xs.size and xs[j1+1]<=xi+rx:
            j1 += 1
        band = (np.abs(rs[j0:j1+1]-rs[i]) <= dz)
        if band.sum()-1 >= k:
            keep_ord[i]=True
    keep = np.zeros_like(keep_ord)
    keep[order]=keep_ord
    return keep

def spot_to_beam(spot, sc_orient):
    pair = {1:"gt1",2:"gt1",3:"gt2",4:"gt2",5:"gt3",6:"gt3"}[int(spot)]
    if int(sc_orient) == 0:
        side = "r" if spot in (1,3,5) else "l"
    else:
        side = "l" if spot in (1,3,5) else "r"
    return f"{pair}{side}"

# ------------------ SLIDERULE FETCH ------------------
def fetch_sliderule_tracks(aoi, time_tuple, lmh=(2,3,4), beams_wanted=BEAMS):
    """
    Returns dict[(granule_id, beam)] -> {"x": along-track m, "h": height m, "lon": ..., "lat": ...}
    Along-track computed from UTM distances (consistent with local method).
    """
    from sliderule import icesat2
    icesat2.init(SLIDERULE_ENDPOINT)

    poly = [
        {"lon": aoi[0], "lat": aoi[1]},
        {"lon": aoi[2], "lat": aoi[1]},
        {"lon": aoi[2], "lat": aoi[3]},
        {"lon": aoi[0], "lat": aoi[3]},
        {"lon": aoi[0], "lat": aoi[1]},
    ]
    parms = {"poly": poly, "t0": time_tuple[0], "t1": time_tuple[1], "cnf": list(lmh)}

    gdf = icesat2.atl03sp(parms, resources=None)  # GeoDataFrame
    if gdf is None or len(gdf) == 0:
        print("SlideRule returned no photons for AOI/time.")
        return {}

    # Beam labels
    if "sc_orient" in gdf.columns and "spot" in gdf.columns:
        gdf["beam"] = [spot_to_beam(s, o) for s, o in zip(gdf["spot"], gdf["sc_orient"])]
    else:
        gdf["beam"] = [f"SPOT {s}" for s in gdf.get("spot", np.zeros(len(gdf)))]

    # Granule id column
    granule_col = None
    for cand in ["file_id", "resource", "granule_id", "granule"]:
        if cand in gdf.columns:
            granule_col = cand; break
    if granule_col is None:
        gdf["file_id"] = gdf.get("rgt", 0).astype(str) + "_rgt"
        granule_col = "file_id"

    out = {}
    for gid, sub_g in gdf.groupby(granule_col):
        for b, sub_b in sub_g.groupby("beam"):
            if b not in beams_wanted:
                continue

            # lon/lat robustly
            if "lon" in sub_b.columns and "lat" in sub_b.columns:
                lon = sub_b["lon"].to_numpy(); lat = sub_b["lat"].to_numpy()
            elif "longitude" in sub_b.columns and "latitude" in sub_b.columns:
                lon = sub_b["longitude"].to_numpy(); lat = sub_b["latitude"].to_numpy()
            elif hasattr(sub_b, "geometry"):
                lon = sub_b.geometry.x.to_numpy(); lat = sub_b.geometry.y.to_numpy()
            else:
                continue

            mfin = np.isfinite(lon) & np.isfinite(lat)
            lon, lat = lon[mfin], lat[mfin]
            if lon.size < 5:
                continue

            # heights
            if "height" in sub_b.columns:
                h = sub_b["height"].to_numpy()[mfin]
            elif "h_ph" in sub_b.columns:
                h = sub_b["h_ph"].to_numpy()[mfin]
            elif "z" in sub_b.columns:
                h = sub_b["z"].to_numpy()[mfin]
            else:
                continue

            # along-track via UTM distances
            E, N = to_utm.transform(lon, lat)
            E, N = np.asarray(E), np.asarray(N)
            x = alongtrack_from_EN(E, N)
            x = x - np.nanmin(x)  # normalize per granule

            out[(str(gid), b)] = {"x": x, "h": h, "lon": lon, "lat": lat}
    return out

# ------------------ FILTER + PLOT ------------------
def run_filter_plot(gtx, x_ph, z_ph):
    """Apply robust trend + MAD/density/neighbor filters. Return boolean keep mask."""
    print(f"\n[{gtx}] start: {x_ph.size:,} photons")
    m,b = robust_line(x_ph, z_ph)
    trend = m*x_ph + b
    res = z_ph - trend

    kept = np.ones_like(x_ph, bool)

    if USE_MAD:
        k1 = mad_gate(x_ph, res, WINDOW_M, Q_LOW, Q_HIGH)
        kept &= k1
        print(f"[{gtx}] after MAD: {kept.sum():,}")

    if USE_DENSITY and kept.sum() > 0:
        k2 = density_filter(x_ph[kept], res[kept], DX_BIN, DZ_BIN, MIN_BIN_COUNT)
        tmp = np.zeros_like(kept); tmp[np.flatnonzero(kept)[k2]] = True
        kept = tmp
        print(f"[{gtx}] after density: {kept.sum():,}")

    if USE_NEIGHBOR and kept.sum() > 0:
        k3 = neighbor_filter(
            x_ph[kept],
            res[kept],
            NEI_RX,
            NEI_DZ,
            NEI_K
        )
        tmp = np.zeros_like(kept)
        tmp[np.flatnonzero(kept)[k3]] = True
        kept = tmp
        print(f"[{gtx}] after neighbor: {kept.sum():,}")

    if kept.sum()==0 and ITERATE_ONCE:
        print(f"[{gtx}] nothing kept → auto-relax thresholds and retry MAD only")
        k1 = mad_gate(x_ph, res, max(WINDOW_M,120.0), 0.3, 4.0)
        kept = k1
        print(f"[{gtx}] after relaxed MAD: {kept.sum():,}")

    # Quick plot (optional)
    fig,(ax1,ax2)=plt.subplots(2,1,figsize=(11,6),sharex=True,
                               gridspec_kw={"height_ratios":[2,1]})
    ax1.scatter(x_ph, z_ph, s=1, color="#bdbdbd", label="all (AOI path)")
    ax1.scatter(x_ph[kept], z_ph[kept], s=1, color="crimson", label="kept")
    ax1.plot(x_ph, trend, color="k", lw=1, label="robust trend")
    ax1.set_ylabel("Photon height h_ph (m)")
    ax1.set_title(f"{gtx} — filtered surface   kept {kept.sum():,}/{x_ph.size:,} ({kept.sum()/x_ph.size:.1%})")
    ax1.legend(loc="upper right", fontsize=9)

    ax2.axhline(0, color="k", lw=1)
    ax2.scatter(x_ph[kept], (z_ph - trend)[kept], s=1, color="crimson")
    ax2.set_ylabel("Detrended residual (m)")
    ax2.set_xlabel("Along-track distance (m)")
    plt.tight_layout(); plt.show()

    return kept

# ------------------ MAIN ------------------
def main():
    kept_out = {}  # {(granule, beam): {"x_keep": ..., "z_keep": ...}}

    tracks = fetch_sliderule_tracks(AOI, TIME, lmh=LMH, beams_wanted=BEAMS)
    if not tracks:
        print("No tracks from SlideRule for AOI/time.")
        return

    for (gid, b), d in tracks.items():
        x, h = d["x"], d["h"]
        if x.size < 5:
            continue
        gtx = f"{b} | {gid}"
        kept = run_filter_plot(gtx, x, h)
        kept_out[(gid, b)] = {"x_keep": x[kept], "z_keep": h[kept]}

    # Hand-off example for your kriging/variogram code:
    if kept_out:
        # grab one set to proceed
        (gid, b), val = next(iter(kept_out.items()))
        x_keep, z_keep = val["x_keep"], val["z_keep"]
        print(f"\nSample kept set ready for kriging → (granule={gid}, beam={b})  n={x_keep.size}")
        # Now call your existing functions:
        #   h_emp, g_emp, n_pairs = experimental_variogram(x_keep, z_keep, ...)
        #   xg = np.arange(np.nanmin(x_keep), np.nanmax(x_keep)+1, 1.0)
        #   zg, used = ok1d(x_keep, z_keep, c_keep??, xg, ...)
        # (c_keep is optional in your OK if you don’t prioritize by confidence here)

if __name__=="__main__":
    main()
