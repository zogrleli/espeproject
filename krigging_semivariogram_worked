#!/usr/bin/env python3
# Online-only ATL03 → filter → variogram → kriging → high-pass → H, φ, z0m

import numpy as np
import matplotlib.pyplot as plt
from pyproj import Transformer

# ------------------ CONFIG ------------------
AOI   = (-68.5, 77.30, -67.5, 77.40)
TIME  = ("2019-09-01T00:00:00Z", "2019-09-30T23:59:59Z")
LMH   = [2, 3, 4]
BEAMS = ["gt1l","gt1r","gt2l","gt2r","gt3l","gt3r"]
SLIDERULE_ENDPOINT = "slideruleearth.io"

# Filter params
WINDOW_M   = 80.0
Q_LOW      = 0.5
Q_HIGH     = 3.0
DX_BIN       = 20.0
DZ_BIN       = 3.0
MIN_BIN_COUNT= 3
NEI_RX   = 25.0
NEI_DZ   = 3.0
NEI_K    = 2
USE_MAD = USE_DENSITY = USE_NEIGHBOR = True
ITERATE_ONCE = False

# Kriging / high-pass / H
RANGE_M     = 15.0   # Gaussian R
HP_LAMBDA   = 35.0   # high-pass cutoff (m)
H_WINDOW    = 200.0  # window for H (m)
STEP        = 50.0   # window step (m)

to_utm = Transformer.from_crs("EPSG:4326","EPSG:32620", always_xy=True)

# ------------------ small utils ------------------
def _nanmedian_mad(a):
    med = np.nanmedian(a); mad = np.nanmedian(np.abs(a - med))
    return med, mad

def robust_line(x, y, max_pairs=20000):
    x = np.asarray(x); y = np.asarray(y)
    n = x.size
    if n < 2: return 0.0, (np.nanmedian(y) if n else 0.0)
    rng = np.random.default_rng(0)
    i = rng.integers(0, n, size=min(max_pairs, n))
    j = rng.integers(0, n, size=min(max_pairs, n))
    m = (j != i); i, j = i[m], j[m]
    if i.size == 0:
        A = np.vstack([x, np.ones_like(x)]).T
        m, b = np.linalg.lstsq(A, y, rcond=None)[0]
        return float(m), float(b)
    slopes = (y[j]-y[i])/(x[j]-x[i])
    m = np.nanmedian(slopes); b = np.nanmedian(y - m*x)
    return float(m), float(b)

def alongtrack_from_EN(E, N):
    d = np.hypot(np.diff(E), np.diff(N))
    return np.concatenate(([0.0], np.cumsum(d)))

# ------------------ filters ------------------
def mad_gate(x,res,W,qL,qH):
    xmin,xmax = x.min(), x.max()
    nb = max(1, int(np.ceil((xmax-xmin)/W)))
    edges = np.linspace(xmin, xmax, nb+1)
    idx = np.clip(np.searchsorted(edges, x, side="right")-1, 0, nb-1)
    keep = np.zeros_like(res, bool)
    for b in range(nb):
        m = (idx==b)
        if m.sum()<10: continue
        r = res[m]
        med, mad = _nanmedian_mad(r)
        if mad==0: mad = np.nanmedian(np.abs(r-med))+1e-6
        lo = med - (qL/0.6745)*mad
        hi = med + (qH/0.6745)*mad
        keep[m] = (r>=lo)&(r<=hi)
    return keep

def density_filter(x,res,dx,dz,minc):
    xe = np.arange(x.min(), x.max()+dx, dx)
    ze = np.arange(np.nanmin(res), np.nanmax(res)+dz, dz)
    xi = np.clip(np.searchsorted(xe,x,side="right")-1, 0, len(xe)-2)
    zi = np.clip(np.searchsorted(ze,res,side="right")-1, 0, len(ze)-2)
    flat = xi*(len(ze)-1)+zi
    u,c = np.unique(flat, return_counts=True)
    good = set(u[c>=minc])
    return np.array([(xi[k]*(len(ze)-1)+zi[k]) in good for k in range(x.size)])

def neighbor_filter(x,res,rx,dz,k):
    order = np.argsort(x)
    xs, rs = x[order], res[order]
    keep_ord = np.zeros_like(xs, bool)
    j0 = 0
    for i in range(xs.size):
        xi = xs[i]
        while xs[j0] < xi-rx and j0 < i: j0 += 1
        j1 = i
        while j1+1<xs.size and xs[j1+1]<=xi+rx: j1 += 1
        band = (np.abs(rs[j0:j1+1]-rs[i]) <= dz)
        if band.sum()-1 >= k: keep_ord[i]=True
    keep = np.zeros_like(keep_ord); keep[order]=keep_ord
    return keep

# ------------------ SlideRule fetch ------------------
def spot_to_beam(spot, sc_orient):
    pair = {1:"gt1",2:"gt1",3:"gt2",4:"gt2",5:"gt3",6:"gt3"}[int(spot)]
    side = ("r" if spot in (1,3,5) else "l") if int(sc_orient)==0 else ("l" if spot in (1,3,5) else "r")
    return f"{pair}{side}"

def fetch_sliderule_tracks(aoi, time_tuple, lmh=(2,3,4), beams_wanted=BEAMS):
    from sliderule import icesat2
    icesat2.init(SLIDERULE_ENDPOINT)

    poly = [{"lon": aoi[0], "lat": aoi[1]},
            {"lon": aoi[2], "lat": aoi[1]},
            {"lon": aoi[2], "lat": aoi[3]},
            {"lon": aoi[0], "lat": aoi[3]},
            {"lon": aoi[0], "lat": aoi[1]}]
    parms = {"poly": poly, "t0": time_tuple[0], "t1": time_tuple[1], "cnf": list(lmh)}
    gdf = icesat2.atl03sp(parms, resources=None)
    if gdf is None or len(gdf)==0: return {}

    # beam & granule id
    gdf["beam"] = [spot_to_beam(s,o) for s,o in zip(gdf["spot"], gdf["sc_orient"])]
    granule_col = "file_id" if "file_id" in gdf.columns else "resource"
    if granule_col not in gdf.columns:
        gdf["file_id"] = gdf.get("rgt", 0).astype(str) + "_rgt"; granule_col = "file_id"

    out = {}
    for gid, sub_g in gdf.groupby(granule_col):
        for b, sub_b in sub_g.groupby("beam"):
            if b not in beams_wanted: continue

            # lon/lat
            if "lon" in sub_b.columns:
                lon = sub_b["lon"].to_numpy(); lat = sub_b["lat"].to_numpy()
            elif hasattr(sub_b, "geometry"):
                lon = sub_b.geometry.x.to_numpy(); lat = sub_b.geometry.y.to_numpy()
            else:
                continue
            mfin = np.isfinite(lon)&np.isfinite(lat)
            lon, lat = lon[mfin], lat[mfin]
            if lon.size < 5: continue

            # height & confidence
            if "height" in sub_b.columns: h = sub_b["height"].to_numpy()[mfin]
            elif "h_ph" in sub_b.columns:  h = sub_b["h_ph"].to_numpy()[mfin]
            else: continue
            conf = (sub_b["cnf"].to_numpy()[mfin] if "cnf" in sub_b.columns
                    else np.full_like(h, 4, dtype=int))

            # along-track (normalize per granule)
            E,N = to_utm.transform(lon, lat); E,N = np.asarray(E), np.asarray(N)
            x = alongtrack_from_EN(E,N); x = x - np.nanmin(x)

            out[(str(gid), b)] = {"x": x, "h": h, "lon": lon, "lat": lat, "cnf": conf}
    return out

# ------------------ variogram & kriging ------------------
def experimental_variogram(x, z, maxlag=150.0, nbins=30, nmax=8000, seed=0):
    x, z = map(lambda a: np.asarray(a,float), (x,z))
    m = np.isfinite(x)&np.isfinite(z); x,z = x[m],z[m]
    if x.size>nmax:
        rng=np.random.default_rng(seed)
        idx=rng.choice(x.size,nmax,replace=False); x,z=x[idx],z[idx]
    i,j = np.triu_indices(x.size,k=1)
    h = np.abs(x[i]-x[j]); g = 0.5*(z[i]-z[j])**2
    sel=h<=maxlag; h,g=h[sel],g[sel]
    bins=np.linspace(0,maxlag,nbins+1)
    ctr=0.5*(bins[:-1]+bins[1:])
    gam=np.full(nbins,np.nan); n=np.zeros(nbins,int)
    which=np.digitize(h,bins)-1
    for k in range(nbins):
        mk = which==k
        if np.any(mk): gam[k]=np.mean(g[mk]); n[k]=mk.sum()
    v=~np.isnan(gam); return ctr[v], gam[v], n[v]

def _cov_gauss(h,sill,R): return sill*np.exp(-0.5*(h/R)**2)

def ok1d(xo, zo, conf, xg, R=RANGE_M, max_k=100, min_pts=3):
    xo, zo, conf, xg = map(np.asarray, (xo, zo, conf, xg))
    o=np.argsort(xo); xo,zo,conf = xo[o],zo[o],conf[o]
    sill = max(float(np.var(zo)), 1e-4)

    def solve_one(xc, idx):
        n=idx.size
        if n<min_pts: return np.nan
        X,Z = xo[idx], zo[idx]
        C=_cov_gauss(np.abs(X[:,None]-X[None,:]),sill,R)
        C.flat[::n+1]+=1e-6
        A=np.block([[C, np.ones((n,1))],[np.ones((1,n)), np.zeros((1,1))]])
        rhs=np.r_[_cov_gauss(np.abs(X-xc),sill,R), 1.0]
        try: w=np.linalg.solve(A,rhs)[:n]
        except np.linalg.LinAlgError: return np.nan
        return float(w@Z)

    zhat=np.full(xg.size,np.nan)
    for i,xc in enumerate(xg):
        z=np.nan
        for rad in (3.75, 7.5, 15.0):
            near=np.abs(xo-xc)<=rad
            for mask in [(conf==4)&near, ((conf>=3)&near), near]:
                idx=np.where(mask)[0]
                if idx.size:
                    idx=idx[np.argsort(np.abs(xo[idx]-xc))[:max_k]]
                    z_try=solve_one(xc, idx)
                    if np.isfinite(z_try): z=z_try; break
            if np.isfinite(z): break
        zhat[i]=z
    return zhat

# ------------------ high-pass & H/phi/z0m ------------------
def highpass_profile(xg, zg, lambda_c=HP_LAMBDA):
    z = np.array(zg, float)
    if np.count_nonzero(np.isfinite(z)) < 10: return np.full_like(z, np.nan)
    zmir = np.r_[z[::-1], z, z[::-1]]
    L = int(round(lambda_c)); L += 1 - (L % 2 == 1)
    w = np.isfinite(zmir).astype(float)
    z0 = np.where(np.isfinite(zmir), zmir, 0.0)
    k = np.ones(L)
    num = np.convolve(z0, k, mode="same")
    den = np.convolve(w,  k, mode="same")
    low = num / np.maximum(den, 1e-12); low[den<1]=np.nan
    low = low[len(z):2*len(z)]
    return z - low

def obstacles_H_phi(xg, zhp, L=H_WINDOW, step=STEP):
    x0,x1=np.nanmin(xg),np.nanmax(xg)
    centers=np.arange(x0+L/2, x1-L/2+1e-6, step)
    Hs,phis=[],[]
    for xc in centers:
        sel=(xg>=xc-L/2)&(xg<=xc+L/2); zf=zhp[sel]
        if np.count_nonzero(np.isfinite(zf))<50: Hs.append(np.nan); phis.append(np.nan); continue
        zf = zf - np.nanmean(zf)
        H  = 2.0*float(np.nanstd(zf))
        pos = np.nan_to_num(zf, nan=0.0) > 0.0
        f = int(np.sum((~pos[:-1]) & (pos[1:])))
        phi = (f * H) / L
        Hs.append(H); phis.append(phi)
    return centers, np.array(Hs), np.array(phis)

def z0m_from_H_phi(H, phi):
    X=np.sqrt(7.5*np.maximum(phi,0.0))
    d = H*(1.0 - np.where(X>0,(1.0-np.exp(-X))/X,1.0))
    k=0.4; psi_hat=0.193
    with np.errstate(divide='ignore', invalid='ignore'):
        uH_over_ustar = 0.8 * H / np.maximum(H - d, 1e-3)  # compact proxy
        z0 = (H - d) * np.exp(-(k*uH_over_ustar - psi_hat))
    z0 = np.where(np.isfinite(z0), z0, np.nan)
    return np.clip(z0, 1e-6, None)

# ------------------ filtering plot ------------------
def run_filter_plot(gtx, x_ph, z_ph):
    print(f"\n[{gtx}] start: {x_ph.size:,} photons")
    m,b = robust_line(x_ph, z_ph)
    trend = m*x_ph + b
    res = z_ph - trend
    kept = np.ones_like(x_ph, bool)
    if USE_MAD:
        kept &= mad_gate(x_ph, res, WINDOW_M, Q_LOW, Q_HIGH)
        print(f"[{gtx}] after MAD: {kept.sum():,}")
    if USE_DENSITY and kept.sum()>0:
        k2 = density_filter(x_ph[kept], res[kept], DX_BIN, DZ_BIN, MIN_BIN_COUNT)
        tmp = np.zeros_like(kept); tmp[np.flatnonzero(kept)[k2]] = True; kept = tmp
        print(f"[{gtx}] after density: {kept.sum():,}")
    if USE_NEIGHBOR and kept.sum()>0:
        k3 = neighbor_filter(x_ph[kept], res[kept], NEI_RX, NEI_DZ, NEI_K)
        tmp = np.zeros_like(kept); tmp[np.flatnonzero(kept)[k3]] = True; kept = tmp
        print(f"[{gtx}] after neighbor: {kept.sum():,}")

    # quick diagnostic plot
    fig,(ax1,ax2)=plt.subplots(2,1,figsize=(11,6),sharex=True,gridspec_kw={"height_ratios":[2,1]})
    ax1.scatter(x_ph, z_ph, s=1, color="0.8", label="all")
    ax1.scatter(x_ph[kept], z_ph[kept], s=1, color="crimson", label="kept")
    ax1.plot(x_ph, trend, color="k", lw=1, label="trend")
    ax1.set_ylabel("h_ph (m)"); ax1.legend(loc="upper right", fontsize=9)
    ax1.set_title(f"{gtx} — kept {kept.sum():,}/{x_ph.size:,} ({kept.sum()/x_ph.size:.1%})")
    ax2.axhline(0,color="k",lw=1)
    ax2.scatter(x_ph[kept], (z_ph-trend)[kept], s=1, color="crimson")
    ax2.set_ylabel("residual (m)"); ax2.set_xlabel("Along-track (m)")
    plt.tight_layout(); plt.show()
    return kept

# ------------------ MAIN ------------------
def main():
    tracks = fetch_sliderule_tracks(AOI, TIME, lmh=LMH, beams_wanted=BEAMS)
    if not tracks:
        print("No tracks from SlideRule for AOI/time."); return

    # process each (granule, beam)
    for (gid, b), d in tracks.items():
        x_all, z_all, conf_all = d["x"], d["h"], d["cnf"]
        if x_all.size < 5: continue
        tag = f"{b} | {gid}"

        kept = run_filter_plot(tag, x_all, z_all)
         
        x_keep, z_keep, c_keep = x[kept], h[kept], d["cnf"][kept]
        kept_out[(gid, b)] = {"x_keep": x_keep, "z_keep": z_keep, "c_keep": c_keep}
        # inside main(), right after:
        (gid, b), val = next(iter(kept_out.items()))
        x_keep, z_keep, c_keep = val["x_keep"], val["z_keep"], val["c_keep"]

# Variogram (optional)
        h_emp, g_emp, n_pairs = experimental_variogram(x_keep, z_keep, maxlag=150, nbins=30, nmax=8000)

# Kriging → 1 m grid
        xg = np.arange(np.nanmin(x_keep), np.nanmax(x_keep) + 1.0, 1.0)
        zg = ok1d(x_keep, z_keep, c_keep, xg, R=15.0, max_k=100, min_pts=3)

      # High-pass → H, φ, z0m
        zhp = highpass_profile(xg, zg, lambda_c=35.0)
        xc, H, phi = obstacles_H_phi(xg, zhp, L=200.0, step=50.0)
        z0m = z0m_from_H_phi(H, phi)

        # quick plots …

        # 1) variogram (diagnostic)
        h_emp, g_emp, n_pairs = experimental_variogram(x_keep, z_keep, maxlag=150, nbins=30, nmax=8000)
        if h_emp.size:
            h_line = np.linspace(0, np.nanmax(h_emp), 300)
            nug = float(np.nanmin(g_emp)); sill = float(max(1e-8, np.nanmax(g_emp)-nug))
            g_line = nug + sill*(1.0 - np.exp(-0.5*(h_line/RANGE_M)**2))
            fig, ax = plt.subplots(figsize=(7,4))
            ax.plot(h_emp,g_emp,"o",ms=4,label="Experimental γ(h)")
            ax.plot(h_line,g_line,"-",lw=2,label=f"Gaussian R={RANGE_M:.0f} m")
            ax.set(xlabel="Lag h (m)", ylabel="γ(h)"); ax.grid(alpha=0.3); ax.legend()
            ax2=ax.twinx(); w=(h_emp[-1]-h_emp[0])/max(10,len(h_emp))
            ax2.bar(h_emp,n_pairs,width=w,alpha=0.15); ax2.set_ylabel("# pairs")
            ax.set_title(f"Semivariogram — {tag}"); plt.tight_layout(); plt.show()

        # 2) kriging to 1 m
        xg = np.arange(np.nanmin(x_keep), np.nanmax(x_keep)+1.0, 1.0)
        zg = ok1d(x_keep, z_keep, c_keep, xg, R=RANGE_M, max_k=100, min_pts=3)

        # quick profile
        m = np.isfinite(zg)
        plt.figure(figsize=(12,4))
        plt.scatter(x_keep[::3], z_keep[::3], s=2, c="0.85", label="kept photons")
        plt.plot(xg[m], zg[m], lw=1.8, label=f"Kriged (R={RANGE_M:.0f} m)")
        plt.title(f"1 m profile — {tag}"); plt.xlabel("Along-track (m)"); plt.ylabel("z (m)")
        plt.grid(alpha=0.25); plt.legend(); plt.tight_layout(); plt.show()

        # 3) high-pass → 4) H & φ → 5) z0m
        zhp = highpass_profile(xg, zg, lambda_c=HP_LAMBDA)
        xc, H, phi = obstacles_H_phi(xg, zhp, L=H_WINDOW, step=STEP)
        z0m = z0m_from_H_phi(H, phi)

        fig, axs = plt.subplots(3,1, figsize=(12,7), sharex=True)
        axs[0].plot(xg, zg, lw=1.2); axs[0].set_ylabel("z (m)")
        axs[0].set_title(f"Kriged profile — {tag}")
        axs[1].plot(xg, zhp, lw=1.0); axs[1].axhline(0,color="k",lw=0.5,alpha=0.4)
        axs[1].set_ylabel("high-pass z (m)"); axs[1].set_title(f"High-pass (λ={HP_LAMBDA:.0f} m)")
        axs[2].plot(xc, H, lw=1.5, label="H")
        ax2 = axs[2].twinx(); ax2.plot(xc, z0m, lw=1.0, ls="--", label="z0m", color="C1")
        axs[2].set_ylabel("H (m)"); axs[2].set_xlabel("Along-track (m)")
        axs[2].grid(alpha=0.25); axs[2].set_title(f"H ({H_WINDOW:.0f} m windows, step {STEP:.0f} m)")
        plt.tight_layout(); plt.show()

if __name__ == "__main__":
    main()
